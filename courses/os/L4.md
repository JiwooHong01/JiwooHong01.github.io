<h1><span class="highlight-title">[4] OS - threads</span></h1>
<h1><span class="highlight-title">1. Background</span></h1>
<h1><span class="highlight-text">process 모델의 한계</span></h1>
- cooperating process: 웹서버가 process fork 너무 많이 하면 자기 자신의 카피를 너무 많이 하게됨. 이렇게 되면, memory 사용부터 여러 비효율적인 문제가 발생하게 된다. 똑같은 걸 1000개씩이나 copy해야하나?
- multiprocessing : 전통적인 processs는 multiprocessor architecture의 장점을 가질 수 없다. 왜냐하면 프로세스는 단 하나의 프로세서만 가능하기 때문이다.
멀티 프로세서여도, 하나의 프로세서가 과연 cpu가 많다고 더 빠른가? 아니다. 왜냐하면 어차피 1개 프로세스는 1개 cpu만 가능하니까..
- 즉, Process가 오버헤드가 너무 많음. 왜냐하면 모든 자료구조가 할당되고 초기화되어야하기 때문. IPC도 OS를 거쳐서 통신하므로 너무 오버헤드가 많음
<h1><span class="highlight-title">2. Thread model</span></h1>
thread란? 프로그램 내에서 실행되는 명령어의 sequence. 이는 PC(program counter)와 local variable, return register을 추적하는 stack으로 이루어진다.
thread는 프로세스 명령어와 대부분의 데이터들을 공유한다. 심지어는 OS의 상태도 공유한다. global, program context까지도 공유할 수 있다.
전통적인 process의 모습